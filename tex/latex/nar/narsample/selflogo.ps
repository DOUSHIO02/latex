%!PS-Adobe-2.0 EPSF-2.0
%%Title: makelogo 9.30
%%Creator: Tom Schneider, toms@ncifcrf.gov
%%BoundingBox:   175   312   505   666
%%Pages: atend
%%DocumentFonts:
%%EndComments
/llx 175.4 def
/lly 311.8 def
/urx 504.9 def
/ury 666.1 def
% * dalvec 2.20
% * rseq 5.36 rsequence calculated from encoded sequences from:
% * encode 1.35; encoding of sequences in
% * * 1997/09/10 13:19:42, 1997/04/27 14:05:39, fis sites version = 1.79 of inst.fis 1996 October 17
% *
% * position, number of sequences, information Rs, variance of Rs
%
% logo from -7 to 7

/cmfactor 72 2.54 div def % defines points -> cm conversion
/cm {cmfactor mul} bind def % defines centimeters

% user defined parameters
/lowest -7 def
/highest 7 def
/bar 100 def
/xcorner  7.18750 cm def
/ycorner 16.00000 cm def
/rotation  0.00000 def % degrees
/charwidth  0.37500 cm def
/charwidth2m charwidth 2 mul def
/barheight  4.00000 cm def
/barwidth  0.05000 cm def
/barbits -2.00000 def % bits
/Ibeamfraction  1.00000 def
/barends (l) def
/subticsBig 2 def % sub-tic interval size (1/bits)
/subticsSmall 10 def % sub-tic interval size (1/bits)
/showingbox (n) def
/outline false def
/caps true def
/stacksperline 15 def
/linesperpage 1 def
/linemove  1.00000 def
/numbering true def
/shrinking false def
/edgecontrol (s) def
/edgeleft  1.00000 def
/edgeright  5.00000 def
/edgelow  5.00000 def
/edgehigh  3.50000 def
/shrink  1.00000 def
/ShowEnds (d) def % d: DNA, p: PROTEIN, -: none
/HalfWhiteIbeam false def

/knirhs 1 shrink sub 2 div def
/charwidth4 charwidth 4 div def
/charwidth2 charwidth 2 div def

/outlinewidth {charwidth 32 div} def
/setthelinewidth {% set the linewidth
  outline
    {outlinewidth setlinewidth}
    {1 setlinewidth}
  ifelse
} def
/toggleoutline { % switch the state of outlineing
pop pop pop pop
/outline outline not def
setthelinewidth
} def

% define fonts
/ffss {findfont fontsize scalefont setfont} def
/FontForStringRegular {/Times-Bold       ffss} def
/FontForStringItalic  {/Times-BoldItalic ffss} def
/FontForLogo          {/Helvetica-Bold   ffss} def
/FontForPrime         {/Symbol           ffss} def
/FontForSymbol        {/Symbol           ffss} def

% Set up the font size for the graphics
/fontsize charwidth def

% movements to place 5' and 3' symbols
/fivemovex {0} def
/fivemovey {(0) charparams lx ux sub 3 mul} def
/threemovex {(0) stringwidth pop 0.5 mul} def
/threemovey {fivemovey} def
/prime {FontForPrime (\242) show FontForStringRegular} def

% make italics possible in titles
/IT {% TRstring ITstring IT -
  exch show
  FontForStringItalic
  show
  FontForStringRegular
} def


% make symbols possible in titles
/SY {% TRstring SYstring SY -
  exch show
  FontForSymbol
  show
  FontForStringRegular
} def

%(*[[ This special comment allows deletion of the repeated
% procedures when several logos are concatenated together
% See the censor program.

/charparams { % char charparams => uy ux ly lx
% takes a single character and returns the coordinates that
% defines the outer bounds of where the ink goes
  gsave
    newpath
    0 0 moveto
    % take the character off the stack and use it here:
    true charpath 
    flattenpath 
    pathbbox % compute bounding box of 1 pt. char => lx ly ux uy
    % the path is here, but toss it away ...
  grestore
  /uy exch def
  /ux exch def
  /ly exch def
  /lx exch def
} bind def

/dashbox { % xsize ysize dashbox -
% draw a dashed box of xsize by ysize (in points)
  /ysize exch def % the y size of the box
  /xsize exch def % the x size of the box
  1 setlinewidth
  gsave
    % Define the width of the dashed lines for boxes:
    newpath
    0 0 moveto
    xsize 0 lineto
    xsize ysize lineto
    0 ysize lineto
    0 0 lineto
    [3] 0 setdash
    stroke
  grestore
  setthelinewidth
} bind def

/boxshow { % xsize ysize char boxshow
% show the character with a box around it, sizes in points
gsave
  /tc exch def % define the character
  /ysize exch def % the y size of the character
  /xsize exch def % the x size of the character
  /xmulfactor 1 def /ymulfactor 1 def

  % if ysize is negative, make everything upside down!
  ysize 0 lt {
    % put ysize normal in this orientation
    /ysize ysize abs def
    xsize ysize translate
    180 rotate
  } if

  shrinking {
    xsize knirhs mul ysize knirhs mul translate
    shrink shrink scale
  } if

  2 {
    gsave
    xmulfactor ymulfactor scale
    tc charparams
    grestore

    ysize % desired size of character in points
    uy ly sub % height of character in points
    dup 0.0 ne {
      div % factor by which to scale up the character
      /ymulfactor exch def
    } % end if
    {pop pop}
    ifelse

    xsize % desired size of character in points
    ux lx sub % width of character in points
    dup 0.0 ne {
      div % factor by which to scale up the character
      /xmulfactor exch def
    } % end if
    {pop pop}
    ifelse
  } repeat

  % Adjust horizontal position if the symbol is an I
  tc (I) eq {charwidth 2 div % half of requested character width
             ux lx sub 2 div % half of the actual character
                sub      0 translate} if
  % Avoid x scaling for I
  tc (I) eq {/xmulfactor 1 def} if

  /xmove xmulfactor lx mul neg def
  /ymove ymulfactor ly mul neg def

  newpath
  xmove ymove moveto
  xmulfactor ymulfactor scale

  outline {  % outline characters:
setthelinewidth
    tc true charpath
    gsave 1 setgray fill grestore
    clip stroke
}
  { % regular characters
    tc show
  }
  ifelse
grestore
} def

/numchar{ % charheight character numchar
% Make a character of given height in cm,
% then move vertically by that amount
  gsave
    /char exch def
    /charheight exch cm def
    /visible true def % most characters are visible
    char (A) eq {  0.1821 1   0.1819 setrgbcolor} if
    char (a) eq {  0.1821 1   0.1819 setrgbcolor} if
    char (C) eq {0   0.9372 1 setrgbcolor} if
    char (c) eq {0   0.9372 1 setrgbcolor} if
    char (T) eq {1 0 0 setrgbcolor} if
    char (t) eq {1 0 0 setrgbcolor} if
    char (U) eq {1 0 0 setrgbcolor} if
    char (u) eq {1 0 0 setrgbcolor} if
    char (G) eq {1   0.7000 0 setrgbcolor} if
    char (g) eq {1   0.7000 0 setrgbcolor} if
     visible {
       % implement boxes, fill and characters:
       showingbox (s) eq
       showingbox (f) eq
       or
       {gsave
           ly lx
           ly charwidth add
           lx charheight add
           boxsymbol
           clip
           showingbox (f) eq
           {fill}  
           {gsave 0 setgray stroke grestore  
            charwidth charheight char boxshow
           }
           ifelse
       grestore
       }
       {charwidth charheight char boxshow}
       ifelse
     } if % visibility control
  grestore
  charheight abs 1 gt {0 charheight abs translate} if
} bind def

/Ibar{
% make a horizontal bar
gsave
  newpath
    charwidth4 neg 0 moveto
    charwidth4 0 lineto
  stroke
grestore
} bind def

/Ibeam{ % height Ibeam
% Make an Ibeam of twice the given height, in cm
  /height exch cm def
  /heightDRAW height Ibeamfraction mul def
  1 setlinewidth
     HalfWhiteIbeam outline not and
     {0.75 setgray} % grey on bottom
     {0 setgray} % black on bottom
  ifelse
  gsave
    charwidth2 height neg translate
    Ibar
    newpath
      0 0 moveto
      0 heightDRAW rlineto
    stroke
    0 setgray % black on top
    newpath
      0 height moveto
      0 height rmoveto
      currentpoint translate
    Ibar
    newpath
      0 0 moveto
      0 heightDRAW neg rlineto
      currentpoint translate
    stroke
  grestore
  setthelinewidth
} bind def

/makenumber { % number makenumber
% make the number
gsave
  shift % shift to the other side of the stack
  90 rotate % rotate so the number fits
  dup stringwidth pop % find the length of the number
  neg % prepare for move
  charwidth (0) charparams uy ly sub % height of numbers
  sub 2 div %
  moveto % move back to provide space
  show
grestore
} bind def

/shift{ % move to the next horizontal position
charwidth 0 translate
} bind def

/bar2 barwidth 2 div def
/bar2n bar2 neg def
/makebar { % make a vertical bar at the current location
gsave
   bar2n 0 moveto
   barwidth 0 rlineto
   0 barheight rlineto
   barwidth neg 0 rlineto
   closepath
   fill
grestore
} def

% definitions for maketic
/str 10 string def % string to hold number
% points of movement between tic marks:
% (abs protects against barbits being negative)
/ticmovement barheight barbits abs div def

/maketic { % make tic marks and numbers
% define tic mark to be the width of the number 4:
(4) stringwidth pop
/ticwidth exch def % width of tic (as a dash) to show
gsave
  % initial increment limit proc for
  0 1 barbits abs cvi
  {/loopnumber exch def

    % convert the number coming from the loop to a string
    % and find its width
    loopnumber 10 str cvrs
    /stringnumber exch def % string representing the number

    stringnumber stringwidth pop
    /numberwidth exch def % width of number to show

    /halfnumberheight
      stringnumber charparams % capture sizes
      uy ly sub 2 div
    def


    numberwidth % move back width of number
    neg loopnumber ticmovement mul % shift on y axis
    halfnumberheight sub % down half the digit

    moveto % move back the width of the string

    ticwidth neg 0 rmoveto % move back the width of the tic

    stringnumber show

    % now show the tic mark
    0 halfnumberheight rmoveto % shift up again
    ticwidth 0 rlineto
    stroke
  } for
grestore

% do additional BIG tic marks.  subtics is user defined
  % initial increment limit proc for
gsave
  0 1 barbits subticsBig mul abs cvi
  {/bitnumber exch subticsBig div subticsBig div def
    0
    neg bitnumber ticmovement mul subticsBig mul % shift on y axis
    moveto
    ticwidth neg 0 rlineto
    stroke
  } for
/subticsBig 10 def % sub-tic interval size (1/bits)
% do additional SMALL tic marks.  subticsSmall is user defined
/ticwidth ticwidth 2 div def % halve the ticwidth
  % initial increment limit proc for
gsave
  0 1 barbits subticsSmall mul abs cvi
  {/bitnumber exch subticsSmall div subticsSmall div def
    0
    neg bitnumber ticmovement mul subticsSmall mul % shift on y axis
    moveto
    ticwidth neg 0 rlineto
    stroke
  } for
grestore
gsave
  /labelstring (bits) def
  numberwidth neg 2.5 mul
  barheight
  labelstring stringwidth pop
  sub 2 div
  translate
  90 rotate
  0 0 moveto
  labelstring show
grestore
} def

/degpercycle 360 def
 
/drawcosine {% amplitude  phase  wavelength  base
%              xmin ymin xmax ymax step
%              dashon dashoff dashoffset thickness
%              cosine -
% draws a cosine wave with the given parameters:
% amplitude (points): height of the wave
% phase (points): starting point of the wave
% wavelength (points): length from crest to crest
% base (points): lowest point of the curve
% xmin ymin xmax ymax (points): region in which to draw
% step steps for drawing a cosine wave
% dashon if greater than zero, size of dashes of the wave (points)
% dashon dashing on interval (points)
% dashoff dashing off interval (points)
% dashoffset offset for dashing (points)
% thickness if greater than zero, thickness of wave (points)
% use dashon and dashoff as blank and dashoffset as 0 for solid line
% See PostScrirt Language Reference Manual 2nd ed p. 500 on dash.

  /thickness exch def
  /dashoffset exch def
  /dashoff exch def
  /dashon exch def
  /step exch def
  /ymax exch def
  /xmax exch def
  /ymin exch def
  /xmin exch def
  /base exch def
  /wavelength exch def
  /phase exch def
  /amplitude exch def
  % fun := amplitude*cos( ((-y-phase)/wavelength)*360) + base
  /fun {phase sub wavelength div degpercycle mul cos
           amplitude mul base add} def

  gsave
    /originallinewidth currentlinewidth def
    thickness 0 gt {thickness setlinewidth} if

    % Force the curve to fit into the region specified:
    newpath
    xmin ymin moveto
    xmax ymin lineto
    xmax ymax lineto
    xmin ymax lineto
    closepath
    clip

    newpath
    xmin dup fun moveto
    % go to xmin-1 and xmax+1 to make sure we overlap the
    % next wave if there is one.  The clip above ensures that it
    % goes no further than requested. 
    % loop from xmin-1 to xmax+1 by step:
    xmin 1 sub step xmax 1 add {dup fun lineto} for
    % turn dash on if dashon is positive
    dashon 0 gt {[dashon cvi dashoff cvi] dashoffset setdash} if
    stroke

    originallinewidth setlinewidth
  grestore
} bind def

/circlesymbol { % x y radius circlesymbol - (path)
newpath 0 360 arc closepath} bind def

/sqrt3 3 sqrt def
/trianglesymbol { % x y radius trianglesymbol - (path)
/r exch def
/sqrt3r sqrt3 r mul def
translate
120 rotate
0 r translate
-120 rotate
newpath
0 0 moveto
sqrt3r 0 lineto
-300 rotate
sqrt3r 0 lineto
closepath} bind def

/squaresymbol { % x y side squaresymbol - (path)
/side exch def
translate
side 2 div neg dup translate
newpath
0 0 moveto
0 side lineto
side side lineto
side 0 lineto
closepath} bind def

/linesymbol { % x1 y1 x2 y2 linesymbol - (path)
/y2 exch def
/x2 exch def
/y1 exch def
/x1 exch def
newpath
x1 y1 moveto
x2 y2 lineto
} bind def

/boxsymbol { % x1 y1 x2 y2 boxsymbol - (path)
/y2 exch def
/x2 exch def
/y1 exch def
/x1 exch def
newpath
x1 y1 moveto
x2 y1 lineto
x2 y2 lineto
x1 y2 lineto
closepath
} bind def

% The following special comment allows deletion of the repeated
% procedures when several logos are concatenated together
% See the censor program.
%]]%*)

/startpage { % start a page
  save % [ startpage
  % set the font used in the title strings
  FontForStringRegular
  gsave % [ startpage
  xcorner ycorner translate
  rotation rotate
  % create the user defined strings
  gsave
    % string number 1
    % center the string
    /stringscale  1.20000 def
    (no shift)
    stringwidth pop
    stringscale mul neg
    stacksperline charwidth mul
    add 2 div
     2.50000 cm moveto
    stringscale stringscale scale
    (no shift)
    show
  grestore
  % now move up to the top of the top line:
  0 linesperpage linemove barheight mul mul translate

  % set the font used in the logos
  FontForLogo
} def

%(*[[ This special comment allows deletion of the repeated
% procedures when several logos are concatenated together
% See the censor program.

/endpage { % end a page
  grestore % ] endpage
  restore % ] endpage
} def

/showleftend {
gsave
 charwidth neg 0 translate
 fivemovex fivemovey moveto ShowEnds (d) eq {(5) show prime} if
 ShowEnds (p) eq {(N) show} if
grestore
} def

/showrightend {
gsave
 threemovex threemovey moveto ShowEnds (d) eq {(3) show prime} if
 ShowEnds (p) eq {(C) show} if
grestore
} def

/startline{ % start a line
% move down to the bottom of the line:
  0 linemove barheight mul neg translate
  gsave % [ startline
  % put a bar on the left side:
  barends (b) eq barends (l) eq or {
    maketic % maketic.startline
    gsave
      bar2n 0 translate % makebar.startline
      makebar % makebar.startline
    grestore
  } if
  showleftend
} def

/endline{ % end a line
  showrightend
  % put a bar on the right side:
  barends (b) eq barends (r) eq or {
    gsave
      bar2 0 translate % makebar.endline
      makebar % makebar.endline
    grestore
  } if
  grestore % ] startline
} def

% @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
% @@@@@@@@@@@@@@@@@@@@ End of procedures @@@@@@@@@@@@@@@@@@@
% @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

% The following special comment allows deletion of the repeated
% procedures when several logos are concatenated together
% See the censor program.
%]]%*)



% Define an arrow
% from page 141 of the PostScript Cookbook
/arrowdict 14 dict def
arrowdict begin
 /mtrx matrix def
end
/arrow
{ arrowdict begin
  /headlength exch def
  /halfheadthickness exch 2 div def
  /halfthickness exch 2 div def
  /tipy exch def /tipx exch def
  /taily exch def /tailx exch def
  /dx tipx tailx sub def
  /dy tipy taily sub def
  /arrowlength dx dx mul dy dy mul add sqrt def
  /angle dy dx atan def
  /base arrowlength headlength sub def
  /savematrix mtrx currentmatrix def
  tailx taily translate
  angle rotate
  0 halfthickness neg moveto
  base halfthickness neg lineto
  base halfheadthickness neg lineto
  arrowlength 0 lineto
  base halfheadthickness lineto
  base halfthickness lineto
  0 halfthickness lineto
  closepath
  savematrix setmatrix
  end
} def

/colorpath {
% color the path.  If fillfirst is true,
% fill the path then stroke, otherwise
% stroke first and then fill.
% fillfirst gives thicker edges.
% the fill color is 'bodycolor'.
% the stroke color is 'strokecolor'.
{ dofill {bodycolor fill} if}
{ dostroke {strokecolor stroke} if}
fillfirst {exch} if
gsave exec grestore % use the path and restore it
exec % use up the path forever
} def

/fixedarrow { % make a fixed position arrow
% These are put on the stack:
%    TailX     TailY     HEadX     HeadY     Shift
%    bases      bits     bases      bits     bases
% The arrow goes from the point (TailX,TailY)
% to the point (HeadX,HeadY), and has a thickness of
% BodyThick around this line segment.
% on the stack give bases to move the arrow
% globally defined parameters:
% BodyThick: thickness of body of arrow
% HeadWidth: How wide the tip of the arrow is
% Headlength: How long the tip of the arrow is
% bodycolor: function that sets the body of the rectangle
% strokecolor: function that sets the edge of the rectangle
% dostroke: stroke if true
% dofill: fill if true
charwidth mul 2 mul 0 translate
BodyThick HeadWidth HeadLength
arrow
colorpath
} def

/fixedrectangle { % make a fixed position rectangle
% on the stack give bases to move the rectangle
% globally defined parameters:
% BodyThick: thickness of body of rectangle
% bodycolor: function that sets the body of the rectangle
% strokecolor: function that sets the edge of the rectangle
% dostroke: stroke if true
% dofill: fill if true
charwidth mul 2 mul 0 translate
BodyThick BodyThick 0
arrow
colorpath
} def

/HTrecompute {
% recompute the head and tail and stick onto stack
% so that they run from the corners.
% Also, define the BodyThick of the arrow
/shiftbase exch def
/hy exch def
/hx exch def
/ty exch def
/tx exch def
/BodyThick hy ty sub abs def
/centery ty hy add 2 div def
tx
centery
hx
centery
shiftbase
} def

/boundarrow { % make an arrow
% Like fixedarrow but the endpoints are
% the opposite ends of the arrow
% so it is easier to position the edges.
% BodyThick of the arrow is computed from these points
HTrecompute
fixedarrow
} def

/boundrectangle { % make a rectangle
% Like fixedrectangle but the endpoints are
% the opposite ends of the rectangle
% so it is easier to position the edges.
% BodyThick of the arrow is computed from these points
HTrecompute
fixedrectangle
} def

% define font size as a unit of measure:
/fs {fontsize mul} def

% standard definitions
/BodyThick     8.00 fs def
/HeadWidth    12.00 fs def
/HeadLength    8.00 fs def
/bodycolor {limegreen} def
/strokecolor {blue} def
/fillfirst true def
/dostroke true def
/dofill true def
1 setlinewidth

% define some convenient colors
/white {1 1 1 setrgbcolor} def
/black {0 0 0 setrgbcolor} def
/red {1 0 0 setrgbcolor} def
/green {0 1 0 setrgbcolor} def
/blue {0 0 1 setrgbcolor} def
/orange {1 0.7 0 setrgbcolor} def
/yellow {1 1 0 setrgbcolor} def
/purple {1 0 1 setrgbcolor} def
/limegreen {0.35 0.1 1.0 sethsbcolor} def
/lightblue {0.60 0.1 1.0 sethsbcolor} def
/lightyellow {0.10 0.1 1.0 sethsbcolor} def
/lightpurple {0.80 0.1 1.0 sethsbcolor} def

% You can change any of the standard definitions
% fs is the font size vertically
% charwidth is assumed to exist (it does in makelogo and lister)
% as the width of the characters horizontally.

/forceforward {% don't do anything so that the next mark position is used
pop pop pop pop % throw away the coordinates
} def

% end of standard part ------------------------------------------------------


/bodycolor {limegreen} def
/HeadWidth     1.00 fs def
/HeadLength    1.50 fs def
/BodyThick     0.40 fs def
%%EndProlog

%%Page: 1 1
startpage % [
startline % line number 1
% at coordinate -7
numbering {(-7) makenumber} if
gsave
 0.02301 (C) numchar
 0.11504 (T) numchar
 0.13805 (A) numchar
 2.48485 (G) numchar
grestore
shift
% at coordinate -6
numbering {(-6) makenumber} if
shift
% at coordinate -5
numbering {(-5) makenumber} if
gsave
 0.04062 (G) numchar
 0.04964 (C) numchar
 0.05641 (A) numchar
 0.12411 (T) numchar
grestore
shift
% at coordinate -4
numbering {(-4) makenumber} if
gsave
 0.03063 (A) numchar
 0.08313 (G) numchar
 0.20564 (T) numchar
 0.20564 (C) numchar
grestore
shift
% at coordinate -3
numbering {(-3) makenumber} if
gsave
 0.04590 (C) numchar
 0.09179 (T) numchar
 0.29068 (G) numchar
 1.40749 (A) numchar
grestore
shift
% at coordinate -2
numbering {(-2) makenumber} if
gsave
 0.07486 (G) numchar
 0.07486 (C) numchar
 0.16844 (T) numchar
 0.43047 (A) numchar
grestore
shift
% at coordinate -1
numbering {(-1) makenumber} if
gsave
 0.04941 (C) numchar
 0.05352 (G) numchar
 0.18116 (T) numchar
 0.20998 (A) numchar
grestore
shift
% at coordinate 0
numbering {(0) makenumber} if
gsave
 0.04735 (G) numchar
 0.04735 (C) numchar
 0.52080 (T) numchar
 0.52080 (A) numchar
grestore
shift
% at coordinate 1
numbering {(1) makenumber} if
gsave
 0.04941 (G) numchar
 0.05352 (C) numchar
 0.18116 (A) numchar
 0.20998 (T) numchar
grestore
shift
% at coordinate 2
numbering {(2) makenumber} if
gsave
 0.07486 (G) numchar
 0.07486 (C) numchar
 0.16844 (A) numchar
 0.43047 (T) numchar
grestore
shift
% at coordinate 3
numbering {(3) makenumber} if
gsave
 0.04590 (G) numchar
 0.09179 (A) numchar
 0.29068 (C) numchar
 1.40749 (T) numchar
grestore
shift
% at coordinate 4
numbering {(4) makenumber} if
gsave
 0.03063 (T) numchar
 0.08313 (C) numchar
 0.20564 (A) numchar
 0.20564 (G) numchar
grestore
shift
% at coordinate 5
numbering {(5) makenumber} if
gsave
 0.04062 (C) numchar
 0.04964 (G) numchar
 0.05641 (T) numchar
 0.12411 (A) numchar
grestore
shift
% at coordinate 6
numbering {(6) makenumber} if
shift
% at coordinate 7
numbering {(7) makenumber} if
gsave
 0.02301 (G) numchar
 0.11504 (A) numchar
 0.13805 (T) numchar
 2.48485 (C) numchar
grestore
shift
gsave
 -3.00000 cm 0 translate
% amplitude  phase  wavelength  base:
 -0.60000 cm  0.18750 cm  3.97500 cm  2.60000 cm
% xmin ymin xmax ymax step:
 -2.62500 cm  0.00000 cm  3.00000 cm  8.30000 cm 1
% dash settings:
 -1.00000 cm -1.00000 cm  0.00000 cm  0.00000 cm drawcosine
grestore
endline
endpage % ]
% Rs total is  7.17931 +/-  0.06984 bits in the range from -7 to 7
%%Trailer
%%Pages: 1
%!PS-Adobe-2.0 EPSF-2.0
%%Title: makelogo 9.30
%%Creator: Tom Schneider, toms@ncifcrf.gov
%%BoundingBox:    10     9   588   780
%%Pages: atend
%%DocumentFonts:
%%EndComments
/llx  10.1 def
/lly   8.9 def
/urx 588.1 def
/ury 779.9 def
% * dalvec 2.20
% * rseq 5.36 rsequence calculated from encoded sequences from:
% * encode 1.35; encoding of sequences in
% * * 1997/09/10 13:19:42, 1997/04/27 14:05:39, fis sites version = 1.79 of inst.fis 1996 October 17
% *
% * position, number of sequences, information Rs, variance of Rs
%
% logo from -7 to 7

/cmfactor 72 2.54 div def % defines points -> cm conversion
/cm {cmfactor mul} bind def % defines centimeters

% user defined parameters
/lowest -7 def
/highest 7 def
/bar 100 def
/xcorner  9.81250 cm def
/ycorner 12.00000 cm def
/rotation  0.00000 def % degrees
/charwidth  0.37500 cm def
/charwidth2m charwidth 2 mul def
/barheight  4.00000 cm def
/barwidth  0.05000 cm def
/barbits -2.00000 def % bits
/Ibeamfraction  1.00000 def
/barends (n) def
/subticsBig 2 def % sub-tic interval size (1/bits)
/subticsSmall 10 def % sub-tic interval size (1/bits)
/showingbox (n) def
/outline false def
/caps true def
/stacksperline 15 def
/linesperpage 1 def
/linemove  1.00000 def
/numbering true def
/shrinking false def
/edgecontrol (p) def
/edgeleft  2.00000 def
/edgeright  2.00000 def
/edgelow  2.00000 def
/edgehigh  2.00000 def
/shrink  1.00000 def
/ShowEnds (d) def % d: DNA, p: PROTEIN, -: none
/HalfWhiteIbeam false def

/knirhs 1 shrink sub 2 div def
/charwidth4 charwidth 4 div def
/charwidth2 charwidth 2 div def

/outlinewidth {charwidth 32 div} def
/setthelinewidth {% set the linewidth
  outline
    {outlinewidth setlinewidth}
    {1 setlinewidth}
  ifelse
} def
/toggleoutline { % switch the state of outlineing
pop pop pop pop
/outline outline not def
setthelinewidth
} def

% define fonts
/ffss {findfont fontsize scalefont setfont} def
/FontForStringRegular {/Times-Bold       ffss} def
/FontForStringItalic  {/Times-BoldItalic ffss} def
/FontForLogo          {/Helvetica-Bold   ffss} def
/FontForPrime         {/Symbol           ffss} def
/FontForSymbol        {/Symbol           ffss} def

% Set up the font size for the graphics
/fontsize charwidth def

% movements to place 5' and 3' symbols
/fivemovex {0} def
/fivemovey {(0) charparams lx ux sub 3 mul} def
/threemovex {(0) stringwidth pop 0.5 mul} def
/threemovey {fivemovey} def
/prime {FontForPrime (\242) show FontForStringRegular} def

% make italics possible in titles
/IT {% TRstring ITstring IT -
  exch show
  FontForStringItalic
  show
  FontForStringRegular
} def


% make symbols possible in titles
/SY {% TRstring SYstring SY -
  exch show
  FontForSymbol
  show
  FontForStringRegular
} def

%(*%*)

/startpage { % start a page
  save % [ startpage
  % set the font used in the title strings
  FontForStringRegular
  gsave % [ startpage
  xcorner ycorner translate
  rotation rotate
  % create the user defined strings
  gsave
    % string number 1
    % center the string
    /stringscale  1.20000 def
    (+7 shift)
    stringwidth pop
    stringscale mul neg
    stacksperline charwidth mul
    add 2 div
     2.50000 cm moveto
    stringscale stringscale scale
    (+7 shift)
    show
  grestore
  % now move up to the top of the top line:
  0 linesperpage linemove barheight mul mul translate

  % set the font used in the logos
  FontForLogo
} def

%(*%*)


/ShiftLettering {
% use:
% triggerbase ignored bases bits sfactor letters red green blue ShiftLettering -
% PostScript definition of the lettering function.
% - Trigger the mark at triggerbase.
% - Make lettering at coordinate (bases, bits)
% - with color as defined by red, green and blue.
% - sfactor is the scale factor: 1.0 is no change, 2.0 is double ...
% The second argument is ignored, so the letters can be anywhere relative to the
% trigger point.
% Multiple letters can be used.
% examples:
% U TRIGGER IGNORED  base   bits  sfactor (letters) R G B ShiftLettering
% U     1.1   0        0    0     1       (A)       0 0 0 ShiftLettering
% U   3.00    0      4.5    0     1       (5\302)   0 0 0 ShiftLettering
% U   3.00    0      4.5    0     1       (5\242)   0 0 0 ShiftLetteringSymbol
% 5\302 makes a 5' symbol, but \242 in the symbol fonts is sharper (recommended).
%
setrgbcolor
/theletters exch def
/sfactor exch def
/y exch def
%/x exch charwidth2m sub def
%/x exch def
/x exch charwidth 2 div sub def
pop pop % FIRST two values are ignored
x y moveto  % move to the given coordinates
gsave
  sfactor dup scale
  theletters show
grestore
}
def

/ShiftLetteringItalic {
% PostScript definition of the lettering function WITH ITALICS
% See ShiftLettering for use
FontForStringItalic % standard font switch
ShiftLettering
FontForStringRegular % standard font switch
}
def

/ShiftLetteringSymbol {
% PostScript definition of the lettering function WITH SYMBOLs
% See ShiftLettering for use
FontForSymbol % standard font switch
ShiftLettering
FontForStringRegular % standard font switch
}
def

/lettering { % bases1 bits1 bases2 bits2 letters red green blue lettering -
% PostScript definition of the lettering function
% make lettering at coordinate (bases1, bits1)
% with color as defined.
% (bases2, bits2) are ignored.
% multiple letters can be used.
% example:
%    bases      bits     IGNORED    IGNORED  (letters) lettering
%
% U      1.1     -0.50     0          0        (A) 0 0 0 lettering
setrgbcolor
/theletters exch def
pop pop % last two values are ignored
/y exch def
/x exch charwidth2m sub def
x y moveto  % move to the given coordinates
theletters show
}
def
 /italiclettering { % bases1 bits1 bases2 bits2 letters
                     % red green blue italiclettering -
% PostScript definition of the lettering function WITH ITALICS
% make italic lettering at coordinate (bases1, bits1)
% with color as defined.
% (bases2, bits2) are ignored.
% multiple letters can be used.
% The routine uses the standard font switches in makelogo and lister
setrgbcolor
/theletters exch def
pop pop % last two values are ignored
/y exch def
/x exch charwidth2m sub def
x y moveto  % move to the given coordinates
FontForStringItalic % standard font switch
theletters show
FontForStringRegular % standard font switch
}
def

/scaledlettering {
% bases1 bits1 bases2 bits2 letters red green blue factor scaledlettering -
% make lettering at coordinate (bases1, bits1)
% with color as defined.
% (bases2, bits2) are ignored.
% multiple letters can be used.
% example:
%    bases      bits     IGNORED    IGNORED  (letters) r g b  factor lettering
% factor is the factor by which to scale the letters
%
% U      1.1     -0.50     0          0        (A) 0 0 0 0.9 lettering
/factor exch def
setrgbcolor
/theletters exch def
pop pop % last two values are ignored
/y exch def
/x exch charwidth2m sub def
x y moveto  % move to the given coordinates
gsave
  factor dup scale
  theletters show
grestore
}
def


% Define an arrow
% from page 141 of the PostScript Cookbook
/arrowdict 14 dict def
arrowdict begin
 /mtrx matrix def
end
/arrow
{ arrowdict begin
  /headlength exch def
  /halfheadthickness exch 2 div def
  /halfthickness exch 2 div def
  /tipy exch def /tipx exch def
  /taily exch def /tailx exch def
  /dx tipx tailx sub def
  /dy tipy taily sub def
  /arrowlength dx dx mul dy dy mul add sqrt def
  /angle dy dx atan def
  /base arrowlength headlength sub def
  /savematrix mtrx currentmatrix def
  tailx taily translate
  angle rotate
  0 halfthickness neg moveto
  base halfthickness neg lineto
  base halfheadthickness neg lineto
  arrowlength 0 lineto
  base halfheadthickness lineto
  base halfthickness lineto
  0 halfthickness lineto
  closepath
  savematrix setmatrix
  end
} def

/colorpath {
% color the path.  If fillfirst is true,
% fill the path then stroke, otherwise
% stroke first and then fill.
% fillfirst gives thicker edges.
% the fill color is 'bodycolor'.
% the stroke color is 'strokecolor'.
{ dofill {bodycolor fill} if}
{ dostroke {strokecolor stroke} if}
fillfirst {exch} if
gsave exec grestore % use the path and restore it
exec % use up the path forever
} def

/fixedarrow { % make a fixed position arrow
% These are put on the stack:
%    TailX     TailY     HEadX     HeadY     Shift
%    bases      bits     bases      bits     bases
% The arrow goes from the point (TailX,TailY)
% to the point (HeadX,HeadY), and has a thickness of
% BodyThick around this line segment.
% on the stack give bases to move the arrow
% globally defined parameters:
% BodyThick: thickness of body of arrow
% HeadWidth: How wide the tip of the arrow is
% Headlength: How long the tip of the arrow is
% bodycolor: function that sets the body of the rectangle
% strokecolor: function that sets the edge of the rectangle
% dostroke: stroke if true
% dofill: fill if true
charwidth mul 2 mul 0 translate
BodyThick HeadWidth HeadLength
arrow
colorpath
} def

/fixedrectangle { % make a fixed position rectangle
% on the stack give bases to move the rectangle
% globally defined parameters:
% BodyThick: thickness of body of rectangle
% bodycolor: function that sets the body of the rectangle
% strokecolor: function that sets the edge of the rectangle
% dostroke: stroke if true
% dofill: fill if true
charwidth mul 2 mul 0 translate
BodyThick BodyThick 0
arrow
colorpath
} def

/HTrecompute {
% recompute the head and tail and stick onto stack
% so that they run from the corners.
% Also, define the BodyThick of the arrow
/shiftbase exch def
/hy exch def
/hx exch def
/ty exch def
/tx exch def
/BodyThick hy ty sub abs def
/centery ty hy add 2 div def
tx
centery
hx
centery
shiftbase
} def

/boundarrow { % make an arrow
% Like fixedarrow but the endpoints are
% the opposite ends of the arrow
% so it is easier to position the edges.
% BodyThick of the arrow is computed from these points
HTrecompute
fixedarrow
} def

/boundrectangle { % make a rectangle
% Like fixedrectangle but the endpoints are
% the opposite ends of the rectangle
% so it is easier to position the edges.
% BodyThick of the arrow is computed from these points
HTrecompute
fixedrectangle
} def

% define font size as a unit of measure:
/fs {fontsize mul} def

% standard definitions
/BodyThick     8.00 fs def
/HeadWidth    12.00 fs def
/HeadLength    8.00 fs def
/bodycolor {limegreen} def
/strokecolor {blue} def
/fillfirst true def
/dostroke true def
/dofill true def
1 setlinewidth

% define some convenient colors
/white {1 1 1 setrgbcolor} def
/black {0 0 0 setrgbcolor} def
/red {1 0 0 setrgbcolor} def
/green {0 1 0 setrgbcolor} def
/blue {0 0 1 setrgbcolor} def
/orange {1 0.7 0 setrgbcolor} def
/yellow {1 1 0 setrgbcolor} def
/purple {1 0 1 setrgbcolor} def
/limegreen {0.35 0.1 1.0 sethsbcolor} def
/lightblue {0.60 0.1 1.0 sethsbcolor} def
/lightyellow {0.10 0.1 1.0 sethsbcolor} def
/lightpurple {0.80 0.1 1.0 sethsbcolor} def

% You can change any of the standard definitions
% fs is the font size vertically
% charwidth is assumed to exist (it does in makelogo and lister)
% as the width of the characters horizontally.

/forceforward {% don't do anything so that the next mark position is used
pop pop pop pop % throw away the coordinates
} def

% end of standard part ------------------------------------------------------



% /bodycolor {green} def
% /strokecolor {bodycolor} def

% /grey {0.5 dup dup setrgbcolor} def
%/bodycolor {grey} def
%/strokecolor {green} def

/bodycolor {green} def
0.25 setlinewidth
/strokecolor {black} def

%/gray {0.5 setgray} def
%/strokecolor {gray} def

%/HeadWidth     1.00 fs def
%/HeadLength    1.50 fs def
%/BodyThick     0.40 fs def

/HeadWidth     0.50 fs def
/HeadLength    0.75 fs def
/BodyThick     0.20 fs def

%%EndProlog

%%Page: 1 1
startpage % [
startline % line number 1
% at coordinate -7
numbering {(-7) makenumber} if
gsave
 0.02301 (C) numchar
 0.11504 (T) numchar
 0.13805 (A) numchar
 2.48485 (G) numchar
grestore
gsave
  0.18750 cm  2.80000 cm  0.18750 cm  3.60000 cm 
     0.00 fixedarrow
grestore
shift
% at coordinate -6
numbering {(-6) makenumber} if
shift
% at coordinate -5
numbering {(-5) makenumber} if
gsave
 0.04062 (G) numchar
 0.04964 (C) numchar
 0.05641 (A) numchar
 0.12411 (T) numchar
grestore
shift
% at coordinate -4
numbering {(-4) makenumber} if
gsave
 0.03063 (A) numchar
 0.08313 (G) numchar
 0.20564 (T) numchar
 0.20564 (C) numchar
grestore
gsave
  0.18750 cm  0.60000 cm  0.18750 cm  3.60000 cm 
     0.00 fixedarrow
grestore
shift
% at coordinate -3
numbering {(-3) makenumber} if
gsave
 0.04590 (C) numchar
 0.09179 (T) numchar
 0.29068 (G) numchar
 1.40749 (A) numchar
grestore
gsave
  0.18750 cm  2.00000 cm  0.18750 cm  3.60000 cm 
     0.00 fixedarrow
grestore
shift
% at coordinate -2
numbering {(-2) makenumber} if
gsave
 0.07486 (G) numchar
 0.07486 (C) numchar
 0.16844 (T) numchar
 0.43047 (A) numchar
grestore
shift
% at coordinate -1
numbering {(-1) makenumber} if
gsave
 0.04941 (C) numchar
 0.05352 (G) numchar
 0.18116 (T) numchar
 0.20998 (A) numchar
grestore
shift
% at coordinate 0
numbering {(0) makenumber} if
gsave
 0.04735 (G) numchar
 0.04735 (C) numchar
 0.52080 (T) numchar
 0.52080 (A) numchar
grestore
gsave
  0.18750 cm  2.84000 cm  0.18750 cm  3.60000 cm 
     0.00 fixedarrow
grestore
gsave
  0.18750 cm  1.30000 cm  0.18750 cm  2.40000 cm 
     0.00 fixedrectangle
grestore

1 setlinewidth
shift
% at coordinate 1
numbering {(1) makenumber} if
gsave
 0.04941 (G) numchar
 0.05352 (C) numchar
 0.18116 (A) numchar
 0.20998 (T) numchar
grestore
shift
% at coordinate 2
numbering {(2) makenumber} if
gsave
 0.07486 (G) numchar
 0.07486 (C) numchar
 0.16844 (A) numchar
 0.43047 (T) numchar
grestore
shift
% at coordinate 3
numbering {(3) makenumber} if
gsave
 0.04590 (G) numchar
 0.09179 (A) numchar
 0.29068 (C) numchar
 1.40749 (T) numchar
grestore
shift
% at coordinate 4
numbering {(4) makenumber} if
gsave
 0.03063 (T) numchar
 0.08313 (C) numchar
 0.20564 (A) numchar
 0.20564 (G) numchar
grestore
shift
% at coordinate 5
numbering {(5) makenumber} if
gsave
 0.04062 (C) numchar
 0.04964 (G) numchar
 0.05641 (T) numchar
 0.12411 (A) numchar
grestore
shift
% at coordinate 6
numbering {(6) makenumber} if
shift
% at coordinate 7
numbering {(7) makenumber} if
gsave
 0.02301 (G) numchar
 0.11504 (A) numchar
 0.13805 (T) numchar
 2.48485 (C) numchar
grestore
shift
gsave
 -3.00000 cm 0 translate
% amplitude  phase  wavelength  base:
 -0.60000 cm  0.18750 cm  3.97500 cm  2.60000 cm
% xmin ymin xmax ymax step:
 -2.62500 cm  0.00000 cm  3.00000 cm  8.30000 cm 1
% dash settings:
  0.10000 cm  0.10000 cm  0.00000 cm  0.00000 cm drawcosine
grestore
gsave
 -3.00000 cm 0 translate
% amplitude  phase  wavelength  base:
 -0.60000 cm -2.43750 cm  3.97500 cm  2.60000 cm
% xmin ymin xmax ymax step:
 -2.62500 cm  0.00000 cm  3.00000 cm  8.30000 cm 1
% dash settings:
 -1.00000 cm -1.00000 cm  0.00000 cm  0.00000 cm drawcosine
grestore
endline
endpage % ]
% Rs total is  7.17931 +/-  0.06984 bits in the range from -7 to 7
%%Trailer
%%Pages: 1
%!PS-Adobe-2.0 EPSF-2.0
%%Title: makelogo 9.30
%%Creator: Tom Schneider, toms@ncifcrf.gov
%%BoundingBox:    10     9   588   780
%%Pages: atend
%%DocumentFonts:
%%EndComments
/llx  10.1 def
/lly   8.9 def
/urx 588.1 def
/ury 779.9 def
% * dalvec 2.20
% * rseq 5.36 rsequence calculated from encoded sequences from:
% * encode 1.35; encoding of sequences in
% * * 1997/09/10 13:19:42, 1997/04/27 14:05:39, fis sites version = 1.79 of inst.fis 1996 October 17
% *
% * position, number of sequences, information Rs, variance of Rs
%
% logo from -7 to 7

/cmfactor 72 2.54 div def % defines points -> cm conversion
/cm {cmfactor mul} bind def % defines centimeters

% user defined parameters
/lowest -7 def
/highest 7 def
/bar 100 def
/xcorner 11.31250 cm def
/ycorner 20.00000 cm def
/rotation  0.00000 def % degrees
/charwidth  0.37500 cm def
/charwidth2m charwidth 2 mul def
/barheight  4.00000 cm def
/barwidth  0.05000 cm def
/barbits -2.00000 def % bits
/Ibeamfraction  1.00000 def
/barends (n) def
/subticsBig 2 def % sub-tic interval size (1/bits)
/subticsSmall 10 def % sub-tic interval size (1/bits)
/showingbox (n) def
/outline false def
/caps true def
/stacksperline 15 def
/linesperpage 1 def
/linemove  1.00000 def
/numbering true def
/shrinking false def
/edgecontrol (p) def
/edgeleft  2.00000 def
/edgeright  2.00000 def
/edgelow  2.00000 def
/edgehigh  2.00000 def
/shrink  1.00000 def
/ShowEnds (d) def % d: DNA, p: PROTEIN, -: none
/HalfWhiteIbeam false def

/knirhs 1 shrink sub 2 div def
/charwidth4 charwidth 4 div def
/charwidth2 charwidth 2 div def

/outlinewidth {charwidth 32 div} def
/setthelinewidth {% set the linewidth
  outline
    {outlinewidth setlinewidth}
    {1 setlinewidth}
  ifelse
} def
/toggleoutline { % switch the state of outlineing
pop pop pop pop
/outline outline not def
setthelinewidth
} def

% define fonts
/ffss {findfont fontsize scalefont setfont} def
/FontForStringRegular {/Times-Bold       ffss} def
/FontForStringItalic  {/Times-BoldItalic ffss} def
/FontForLogo          {/Helvetica-Bold   ffss} def
/FontForPrime         {/Symbol           ffss} def
/FontForSymbol        {/Symbol           ffss} def

% Set up the font size for the graphics
/fontsize charwidth def

% movements to place 5' and 3' symbols
/fivemovex {0} def
/fivemovey {(0) charparams lx ux sub 3 mul} def
/threemovex {(0) stringwidth pop 0.5 mul} def
/threemovey {fivemovey} def
/prime {FontForPrime (\242) show FontForStringRegular} def

% make italics possible in titles
/IT {% TRstring ITstring IT -
  exch show
  FontForStringItalic
  show
  FontForStringRegular
} def


% make symbols possible in titles
/SY {% TRstring SYstring SY -
  exch show
  FontForSymbol
  show
  FontForStringRegular
} def

%(*%*)

/startpage { % start a page
  save % [ startpage
  % set the font used in the title strings
  FontForStringRegular
  gsave % [ startpage
  xcorner ycorner translate
  rotation rotate
  % create the user defined strings
  gsave
    % string number 1
    % center the string
    /stringscale  1.20000 def
    (+11 shift)
    stringwidth pop
    stringscale mul neg
    stacksperline charwidth mul
    add 2 div
     2.80000 cm moveto
    stringscale stringscale scale
    (+11 shift)
    show
  grestore
  % now move up to the top of the top line:
  0 linesperpage linemove barheight mul mul translate

  % set the font used in the logos
  FontForLogo
} def

%(*%*)



% Define an arrow
% from page 141 of the PostScript Cookbook
/arrowdict 14 dict def
arrowdict begin
 /mtrx matrix def
end
/arrow
{ arrowdict begin
  /headlength exch def
  /halfheadthickness exch 2 div def
  /halfthickness exch 2 div def
  /tipy exch def /tipx exch def
  /taily exch def /tailx exch def
  /dx tipx tailx sub def
  /dy tipy taily sub def
  /arrowlength dx dx mul dy dy mul add sqrt def
  /angle dy dx atan def
  /base arrowlength headlength sub def
  /savematrix mtrx currentmatrix def
  tailx taily translate
  angle rotate
  0 halfthickness neg moveto
  base halfthickness neg lineto
  base halfheadthickness neg lineto
  arrowlength 0 lineto
  base halfheadthickness lineto
  base halfthickness lineto
  0 halfthickness lineto
  closepath
  savematrix setmatrix
  end
} def

/colorpath {
% color the path.  If fillfirst is true,
% fill the path then stroke, otherwise
% stroke first and then fill.
% fillfirst gives thicker edges.
% the fill color is 'bodycolor'.
% the stroke color is 'strokecolor'.
{ dofill {bodycolor fill} if}
{ dostroke {strokecolor stroke} if}
fillfirst {exch} if
gsave exec grestore % use the path and restore it
exec % use up the path forever
} def

/fixedarrow { % make a fixed position arrow
% These are put on the stack:
%    TailX     TailY     HEadX     HeadY     Shift
%    bases      bits     bases      bits     bases
% The arrow goes from the point (TailX,TailY)
% to the point (HeadX,HeadY), and has a thickness of
% BodyThick around this line segment.
% on the stack give bases to move the arrow
% globally defined parameters:
% BodyThick: thickness of body of arrow
% HeadWidth: How wide the tip of the arrow is
% Headlength: How long the tip of the arrow is
% bodycolor: function that sets the body of the rectangle
% strokecolor: function that sets the edge of the rectangle
% dostroke: stroke if true
% dofill: fill if true
charwidth mul 2 mul 0 translate
BodyThick HeadWidth HeadLength
arrow
colorpath
} def

/fixedrectangle { % make a fixed position rectangle
% on the stack give bases to move the rectangle
% globally defined parameters:
% BodyThick: thickness of body of rectangle
% bodycolor: function that sets the body of the rectangle
% strokecolor: function that sets the edge of the rectangle
% dostroke: stroke if true
% dofill: fill if true
charwidth mul 2 mul 0 translate
BodyThick BodyThick 0
arrow
colorpath
} def

/HTrecompute {
% recompute the head and tail and stick onto stack
% so that they run from the corners.
% Also, define the BodyThick of the arrow
/shiftbase exch def
/hy exch def
/hx exch def
/ty exch def
/tx exch def
/BodyThick hy ty sub abs def
/centery ty hy add 2 div def
tx
centery
hx
centery
shiftbase
} def

/boundarrow { % make an arrow
% Like fixedarrow but the endpoints are
% the opposite ends of the arrow
% so it is easier to position the edges.
% BodyThick of the arrow is computed from these points
HTrecompute
fixedarrow
} def

/boundrectangle { % make a rectangle
% Like fixedrectangle but the endpoints are
% the opposite ends of the rectangle
% so it is easier to position the edges.
% BodyThick of the arrow is computed from these points
HTrecompute
fixedrectangle
} def

% define font size as a unit of measure:
/fs {fontsize mul} def

% standard definitions
/BodyThick     8.00 fs def
/HeadWidth    12.00 fs def
/HeadLength    8.00 fs def
/bodycolor {limegreen} def
/strokecolor {blue} def
/fillfirst true def
/dostroke true def
/dofill true def
1 setlinewidth

% define some convenient colors
/white {1 1 1 setrgbcolor} def
/black {0 0 0 setrgbcolor} def
/red {1 0 0 setrgbcolor} def
/green {0 1 0 setrgbcolor} def
/blue {0 0 1 setrgbcolor} def
/orange {1 0.7 0 setrgbcolor} def
/yellow {1 1 0 setrgbcolor} def
/purple {1 0 1 setrgbcolor} def
/limegreen {0.35 0.1 1.0 sethsbcolor} def
/lightblue {0.60 0.1 1.0 sethsbcolor} def
/lightyellow {0.10 0.1 1.0 sethsbcolor} def
/lightpurple {0.80 0.1 1.0 sethsbcolor} def

% You can change any of the standard definitions
% fs is the font size vertically
% charwidth is assumed to exist (it does in makelogo and lister)
% as the width of the characters horizontally.

/forceforward {% don't do anything so that the next mark position is used
pop pop pop pop % throw away the coordinates
} def

% end of standard part ------------------------------------------------------


% /bodycolor {red} def
% /strokecolor {bodycolor} def

%/bodycolor {white} def
%/strokecolor {red} def

/bodycolor {red} def
0.25 setlinewidth
/strokecolor {black} def

%/gray {0.5 setgray} def
%/strokecolor {gray} def

% /HeadWidth     1.00 fs def
% /HeadLength    1.50 fs def
% /BodyThick     0.40 fs def

/HeadWidth     0.50 fs def
/HeadLength    0.75 fs def
/BodyThick     0.20 fs def
%%EndProlog

%%Page: 1 1
startpage % [
startline % line number 1
% at coordinate -7
numbering {(-7) makenumber} if
gsave
 0.02301 (C) numchar
 0.11504 (T) numchar
 0.13805 (A) numchar
 2.48485 (G) numchar
grestore
gsave
  0.18750 cm -0.50000 cm  0.18750 cm -3.40000 cm 
     0.00 fixedarrow
grestore
shift
% at coordinate -6
numbering {(-6) makenumber} if
shift
% at coordinate -5
numbering {(-5) makenumber} if
gsave
 0.04062 (G) numchar
 0.04964 (C) numchar
 0.05641 (A) numchar
 0.12411 (T) numchar
grestore
shift
% at coordinate -4
numbering {(-4) makenumber} if
gsave
 0.03063 (A) numchar
 0.08313 (G) numchar
 0.20564 (T) numchar
 0.20564 (C) numchar
grestore
gsave
  0.18750 cm -0.50000 cm  0.18750 cm -1.00000 cm 
     0.00 fixedarrow
grestore

1 setlinewidth
shift
% at coordinate -3
numbering {(-3) makenumber} if
gsave
 0.04590 (C) numchar
 0.09179 (T) numchar
 0.29068 (G) numchar
 1.40749 (A) numchar
grestore
shift
% at coordinate -2
numbering {(-2) makenumber} if
gsave
 0.07486 (G) numchar
 0.07486 (C) numchar
 0.16844 (T) numchar
 0.43047 (A) numchar
grestore
shift
% at coordinate -1
numbering {(-1) makenumber} if
gsave
 0.04941 (C) numchar
 0.05352 (G) numchar
 0.18116 (T) numchar
 0.20998 (A) numchar
grestore
shift
% at coordinate 0
numbering {(0) makenumber} if
gsave
 0.04735 (G) numchar
 0.04735 (C) numchar
 0.52080 (T) numchar
 0.52080 (A) numchar
grestore
shift
% at coordinate 1
numbering {(1) makenumber} if
gsave
 0.04941 (G) numchar
 0.05352 (C) numchar
 0.18116 (A) numchar
 0.20998 (T) numchar
grestore
shift
% at coordinate 2
numbering {(2) makenumber} if
gsave
 0.07486 (G) numchar
 0.07486 (C) numchar
 0.16844 (A) numchar
 0.43047 (T) numchar
grestore
shift
% at coordinate 3
numbering {(3) makenumber} if
gsave
 0.04590 (G) numchar
 0.09179 (A) numchar
 0.29068 (C) numchar
 1.40749 (T) numchar
grestore
shift
% at coordinate 4
numbering {(4) makenumber} if
gsave
 0.03063 (T) numchar
 0.08313 (C) numchar
 0.20564 (A) numchar
 0.20564 (G) numchar
grestore
shift
% at coordinate 5
numbering {(5) makenumber} if
gsave
 0.04062 (C) numchar
 0.04964 (G) numchar
 0.05641 (T) numchar
 0.12411 (A) numchar
grestore
shift
% at coordinate 6
numbering {(6) makenumber} if
shift
% at coordinate 7
numbering {(7) makenumber} if
gsave
 0.02301 (G) numchar
 0.11504 (A) numchar
 0.13805 (T) numchar
 2.48485 (C) numchar
grestore
shift
gsave
 -3.00000 cm 0 translate
% amplitude  phase  wavelength  base:
 -0.60000 cm  0.18750 cm  3.97500 cm  2.60000 cm
% xmin ymin xmax ymax step:
 -2.62500 cm  0.00000 cm  3.00000 cm  8.30000 cm 1
% dash settings:
  0.10000 cm  0.10000 cm  0.00000 cm  0.00000 cm drawcosine
grestore
gsave
 -3.00000 cm 0 translate
% amplitude  phase  wavelength  base:
 -0.60000 cm -3.93750 cm  3.97500 cm  2.60000 cm
% xmin ymin xmax ymax step:
 -2.62500 cm  0.00000 cm  3.00000 cm  8.30000 cm 1
% dash settings:
 -1.00000 cm -1.00000 cm  0.00000 cm  0.00000 cm drawcosine
grestore
endline
endpage % ]
% Rs total is  7.17931 +/-  0.06984 bits in the range from -7 to 7
%%Trailer
%%Pages: 1
gsave

%  7 cm 8 cm translate
%  4.9 cm 6.45 cm 6.35 cm 6.82 cm boxsymbol


  11.9 cm 14.45 cm translate
  1 setgray
%  1 1 0 setrgbcolor
  0 cm 0 cm 1.45 cm 0.37 cm boxsymbol
  fill

  0 setgray
  FontForStringRegular
  0.005 cm 0.05 cm moveto
  1.2 dup scale
  (+7 shift) show

grestore
showpage
